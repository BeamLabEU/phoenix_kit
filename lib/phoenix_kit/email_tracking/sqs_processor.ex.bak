defmodule PhoenixKit.EmailTracking.SQSProcessor do
  @moduledoc """
  Processor for handling email events from AWS SQS messages.

  This module is responsible for:
  - Parsing SNS messages from SQS
  - Processing different types of SES events
  - Updating email statuses in the database
  - Creating event records for tracking

  ## Supported Event Types

  - **Send** - Email send confirmation through SES
  - **Delivery** - Successful email delivery to recipient
  - **Bounce** - Email bounce (hard/soft bounce)
  - **Complaint** - Spam complaint
  - **Open** - Email open (pixel tracking)
  - **Click** - Link click in email

  ## Processing Architecture

  ```
  SQS Message → SNS Parsing → Event Processing → Database Update
  ```

  ## Security

  - Message structure validation
  - Event type checking
  - Protection against event duplication
  - Graceful handling of invalid data

  ## Examples

      # Parse SNS message
      {:ok, event_data} = SQSProcessor.parse_sns_message(sqs_message)

      # Process event
      {:ok, result} = SQSProcessor.process_email_event(event_data)

  """

  require Logger
  import Ecto.Query, only: [from: 2]

  alias PhoenixKit.EmailTracking
  alias PhoenixKit.EmailTracking.EmailLog

  ## --- Public API ---

  @doc """
  Parses SNS message from SQS into event data structure.

  ## Parameters

  - `sqs_message` - message from SQS queue

  ## Returns

  - `{:ok, event_data}` - successfully parsed event data
  - `{:error, reason}` - parsing error

  ## Examples

      iex> SQSProcessor.parse_sns_message(sqs_message)
      {:ok, %{
        "eventType" => "delivery",
        "mail" => %{"messageId" => "abc123"},
        "delivery" => %{"timestamp" => "2025-09-20T15:30:45.000Z"}
      }}
  """
  def parse_sns_message(%{"Body" => body}) do
    parse_sns_body(body)
  end

  def parse_sns_message(%{"body" => body}) do
    parse_sns_body(body)
  end

  def parse_sns_message(%{body: body}) do
    parse_sns_body(body)
  end

  def parse_sns_message(_), do: {:error, :invalid_message_format}

  # Helper function to parse SNS body content
  defp parse_sns_body(body) when is_binary(body) do
    Logger.debug("Parsing SNS message body", %{
      body_preview: String.slice(body, 0, 300),
      body_length: String.length(body)
    })

    # Validate body is not empty
    if String.trim(body) == "" do
      Logger.error("Received empty SNS message body")
      {:error, :empty_message_body}
    else
      with {:ok, sns_data} when is_map(sns_data) <- Jason.decode(body),
           {:ok, event_data} <- extract_ses_event(sns_data) do
        {:ok, event_data}
      else
        {:ok, invalid_data} ->
          Logger.error("SNS body decoded but not a map", %{
            data_type: type_of(invalid_data),
            data_preview: inspect(invalid_data) |> String.slice(0, 200)
          })
          {:error, :invalid_sns_format}

        {:error, %Jason.DecodeError{} = error} ->
          Logger.error("Invalid JSON in SNS message body", %{
            error: inspect(error),
            position: error.position,
            body_preview: String.slice(body, 0, 500)
          })
          {:error, :invalid_json}

        {:error, reason} ->
          Logger.debug("SNS message parsing failed", %{reason: reason})
          {:error, reason}
      end
    end
  end

  defp parse_sns_body(_) do
    Logger.error("SNS body is not a binary string")
    {:error, :invalid_body_type}
  end

  # Helper to get type name for better error logging
  defp type_of(data) when is_list(data), do: :list
  defp type_of(data) when is_map(data), do: :map
  defp type_of(data) when is_binary(data), do: :binary
  defp type_of(data) when is_integer(data), do: :integer
  defp type_of(data) when is_float(data), do: :float
  defp type_of(data) when is_atom(data), do: :atom
  defp type_of(_), do: :unknown

  @doc """
  Processes email event and updates corresponding database records.

  ## Parameters

  - `event_data` - event data from SNS

  ## Returns

  - `{:ok, result}` - successful processing
  - `{:error, reason}` - processing error

  ## Examples

      iex> SQSProcessor.process_email_event(event_data)
      {:ok, %{type: "delivery", log_id: 123, updated: true}}
  """
  def process_email_event(event_data) when is_map(event_data) do
    case determine_event_type(event_data) do
      "send" ->
        process_send_event(event_data)

      "delivery" ->
        process_delivery_event(event_data)

      "bounce" ->
        process_bounce_event(event_data)

      "complaint" ->
        process_complaint_event(event_data)

      "open" ->
        process_open_event(event_data)

      "click" ->
        process_click_event(event_data)

      unknown_type ->
        Logger.warning("Unknown email event type", %{type: unknown_type})
        {:error, {:unknown_event_type, unknown_type}}
    end
  end

  def process_email_event(_), do: {:error, :invalid_event_data}

  ## --- Private Helper Functions ---

  # Extracts SES event from SNS message
  defp extract_ses_event(%{"Type" => "Notification", "Message" => message_json}) do
    Logger.debug("Extracting SES event from SNS notification", %{
      message_preview: String.slice(message_json, 0, 200),
      message_length: String.length(message_json)
    })

    # Validate message is not empty
    if String.trim(message_json) == "" do
      Logger.error("Received empty SES message JSON")
      {:error, :empty_ses_message}
    else
      # Check if this is an SNS topic validation message (not a SES event)
      if String.contains?(message_json, "Successfully validated SNS topic") do
        Logger.debug("Ignoring SNS topic validation message")
        {:error, :sns_validation_message}
      else
        # The Message field from SNS contains an escaped JSON string, not a JSON object
        # We need to decode it to get the actual SES event data
        case Jason.decode(message_json) do
        {:ok, ses_event} when is_map(ses_event) ->
          # Validate required fields exist
          event_type = ses_event["eventType"]
          message_id = get_in(ses_event, ["mail", "messageId"])

          if event_type && message_id do
            Logger.debug("Successfully extracted SES event", %{
              event_type: event_type,
              message_id: message_id
            })
            {:ok, ses_event}
          else
            Logger.error("SES event missing required fields", %{
              event_type: event_type,
              message_id: message_id,
              available_keys: Map.keys(ses_event),
              raw_event: inspect(ses_event) |> String.slice(0, 1000)
            })
            {:error, :missing_required_fields}
          end

        {:ok, invalid_data} ->
          Logger.error("SES message decoded but not a map", %{
            data_type: type_of(invalid_data),
            data_preview: inspect(invalid_data) |> String.slice(0, 500)
          })
          {:error, :invalid_ses_format}

        {:error, %Jason.DecodeError{} = error} ->
          Logger.error("Failed to decode SES message JSON - invalid JSON format", %{
            error: inspect(error),
            position: error.position,
            message_preview: String.slice(message_json, 0, 500),
            message_length: String.length(message_json)
          })
          {:error, :invalid_ses_message}

        {:error, reason} ->
          Logger.error("Failed to decode SES message JSON - unknown error", %{
            error: inspect(reason),
            message_preview: String.slice(message_json, 0, 500),
            message_length: String.length(message_json)
          })
          {:error, :invalid_ses_message}
        end
      end
    end
  end

  defp extract_ses_event(%{"Type" => "SubscriptionConfirmation"}) do
    # SNS subscription confirmation - ignore
    {:error, :subscription_confirmation}
  end

  defp extract_ses_event(%{"Type" => "UnsubscribeConfirmation"}) do
    # SNS unsubscribe confirmation - ignore
    {:error, :unsubscribe_confirmation}
  end

  defp extract_ses_event(data) do
    Logger.error("Unknown SNS event format", %{
      data_keys: Map.keys(data),
      data_preview: inspect(data) |> String.slice(0, 500)
    })

    {:error, :unknown_sns_format}
  end

  # Determines event type based on eventType field
  defp determine_event_type(event_data) do
    event_data
    |> Map.get("eventType", "unknown")
    |> String.downcase()
  end

  ## --- Event Processing Functions ---

  # Processes send event
  defp process_send_event(event_data) do
    message_id = get_in(event_data, ["mail", "messageId"])

    case find_email_log_by_message_id(message_id) do
      {:ok, log} ->
        # Send events are usually already processed during log creation
        # Can update additional metadata if needed
        Logger.debug("Send event received for already logged email", %{
          log_id: log.id,
          message_id: message_id
        })

        {:ok, %{type: "send", log_id: log.id, updated: false}}

      {:error, :not_found} ->
        # Rare case - received send event without preliminary logging
        Logger.warning("Send event for unknown email - attempting to create placeholder log", %{
          message_id: message_id
        })

        case create_placeholder_log_from_event(event_data, "sent") do
          {:ok, log} ->
            Logger.info("Created placeholder log for send event", %{
              log_id: log.id,
              message_id: message_id
            })

            {:ok, %{type: "send", log_id: log.id, updated: true, created_placeholder: true}}

          {:error, reason} ->
            Logger.error("Failed to create placeholder log for send event", %{
              message_id: message_id,
              reason: inspect(reason)
            })

            {:error, :email_log_not_found}
        end
    end
  end

  # Processes delivery event
  defp process_delivery_event(event_data) do
    message_id = get_in(event_data, ["mail", "messageId"])
    delivery_data = event_data["delivery"] || %{}
    delivery_timestamp = get_in(delivery_data, ["timestamp"])

    case find_email_log_by_message_id(message_id) do
      {:ok, log} ->
        # Update status to delivered
        update_attrs = %{
          status: "delivered",
          delivered_at: parse_timestamp(delivery_timestamp)
        }

        case EmailLog.update_log(log, update_attrs) do
          {:ok, updated_log} ->
            # Создаем event запись
            create_delivery_event(updated_log, delivery_data)

            Logger.info("Email delivered", %{
              log_id: updated_log.id,
              message_id: message_id,
              delivered_at: updated_log.delivered_at
            })

            {:ok, %{type: "delivery", log_id: updated_log.id, updated: true}}

          {:error, reason} ->
            Logger.error("Failed to update delivery status", %{
              log_id: log.id,
              reason: inspect(reason)
            })

            {:error, reason}
        end

      {:error, :not_found} ->
        Logger.warning(
          "Delivery event for unknown email - attempting to create placeholder log",
          %{message_id: message_id}
        )

        case create_placeholder_log_from_event(event_data, "delivered") do
          {:ok, log} ->
            # Обновляем статус на delivered и добавляем timestamp
            update_attrs = %{
              status: "delivered",
              delivered_at: parse_timestamp(delivery_timestamp)
            }

            case EmailLog.update_log(log, update_attrs) do
              {:ok, updated_log} ->
                # Создаем event запись
                create_delivery_event(updated_log, delivery_data)

                Logger.info("Created placeholder log for delivery event", %{
                  log_id: updated_log.id,
                  message_id: message_id,
                  delivered_at: updated_log.delivered_at
                })

                {:ok,
                 %{
                   type: "delivery",
                   log_id: updated_log.id,
                   updated: true,
                   created_placeholder: true
                 }}

              {:error, reason} ->
                Logger.error("Failed to update placeholder log for delivery", %{
                  log_id: log.id,
                  reason: inspect(reason)
                })

                {:error, reason}
            end

          {:error, reason} ->
            Logger.error("Failed to create placeholder log for delivery event", %{
              message_id: message_id,
              reason: inspect(reason)
            })

            {:error, :email_log_not_found}
        end
    end
  end

  # Обрабатывает событие отскока
  defp process_bounce_event(event_data) do
    message_id = get_in(event_data, ["mail", "messageId"])
    bounce_data = event_data["bounce"]
    # Permanent или Temporary
    bounce_type = get_in(bounce_data, ["bounceType"])
    bounce_subtype = get_in(bounce_data, ["bounceSubType"])

    case find_email_log_by_message_id(message_id) do
      {:ok, log} ->
        # Определяем статус на основе типа bounce
        status =
          case String.downcase(bounce_type || "") do
            "permanent" -> "hard_bounced"
            "temporary" -> "soft_bounced"
            _ -> "bounced"
          end

        update_attrs = %{
          status: status,
          error_message: build_bounce_error_message(bounce_data)
        }

        case EmailLog.update_log(log, update_attrs) do
          {:ok, updated_log} ->
            # Создаем event запись
            create_bounce_event(updated_log, bounce_data)

            Logger.info("Email bounced", %{
              log_id: updated_log.id,
              message_id: message_id,
              bounce_type: bounce_type,
              bounce_subtype: bounce_subtype
            })

            {:ok, %{type: "bounce", log_id: updated_log.id, updated: true}}

          {:error, reason} ->
            Logger.error("Failed to update bounce status", %{
              log_id: log.id,
              reason: inspect(reason)
            })

            {:error, reason}
        end

      {:error, :not_found} ->
        Logger.warning("Bounce event for unknown email", %{message_id: message_id})
        {:error, :email_log_not_found}
    end
  end

  # Обрабатывает событие жалобы
  defp process_complaint_event(event_data) do
    message_id = get_in(event_data, ["mail", "messageId"])
    complaint_data = event_data["complaint"]
    complaint_type = get_in(complaint_data, ["complaintFeedbackType"])

    case find_email_log_by_message_id(message_id) do
      {:ok, log} ->
        update_attrs = %{
          status: "complaint",
          error_message: "Spam complaint: #{complaint_type || "unknown"}"
        }

        case EmailLog.update_log(log, update_attrs) do
          {:ok, updated_log} ->
            # Создаем event запись
            create_complaint_event(updated_log, complaint_data)

            Logger.warning("Email complaint received", %{
              log_id: updated_log.id,
              message_id: message_id,
              complaint_type: complaint_type
            })

            {:ok, %{type: "complaint", log_id: updated_log.id, updated: true}}

          {:error, reason} ->
            Logger.error("Failed to update complaint status", %{
              log_id: log.id,
              reason: inspect(reason)
            })

            {:error, reason}
        end

      {:error, :not_found} ->
        Logger.warning("Complaint event for unknown email - attempting to create placeholder log", %{message_id: message_id})

        case create_placeholder_log_from_event(event_data, "complaint") do
          {:ok, log} ->
            # Обновляем статус на complaint
            update_attrs = %{
              status: "complaint",
              error_message: "Spam complaint: #{complaint_type || "unknown"}"
            }

            case EmailLog.update_log(log, update_attrs) do
              {:ok, updated_log} ->
                # Создаем event запись
                create_complaint_event(updated_log, complaint_data)

                Logger.info("Created placeholder log for complaint event", %{
                  log_id: updated_log.id,
                  message_id: message_id,
                  complaint_type: complaint_type
                })

                {:ok, %{type: "complaint", log_id: updated_log.id, updated: true, created_placeholder: true}}

              {:error, reason} ->
                Logger.error("Failed to update placeholder log for complaint", %{
                  log_id: log.id,
                  reason: inspect(reason)
                })

                {:error, reason}
            end

          {:error, reason} ->
            Logger.error("Failed to create placeholder log for complaint event", %{
              message_id: message_id,
              reason: inspect(reason)
            })

            {:error, :email_log_not_found}
        end
    end
  end

  # Обрабатывает событие открытия email
  defp process_open_event(event_data) do
    message_id = get_in(event_data, ["mail", "messageId"])
    open_data = event_data["open"]
    open_timestamp = get_in(open_data, ["timestamp"])

    case find_email_log_by_message_id(message_id) do
      {:ok, log} ->
        # Обновляем статус только если текущий статус не "clicked"
        # (клик важнее открытия)
        status_update =
          case log.status do
            # Не изменяем
            "clicked" -> %{}
            _ -> %{status: "opened"}
          end

        case EmailLog.update_log(log, status_update) do
          {:ok, updated_log} ->
            # Создаем event запись
            create_open_event(updated_log, open_data, open_timestamp)

            Logger.debug("Email opened", %{
              log_id: updated_log.id,
              message_id: message_id,
              ip_address: get_in(open_data, ["ipAddress"])
            })

            {:ok, %{type: "open", log_id: updated_log.id, updated: true}}

          {:error, reason} ->
            Logger.error("Failed to update open status", %{
              log_id: log.id,
              reason: inspect(reason)
            })

            {:error, reason}
        end

      {:error, :not_found} ->
        Logger.warning("Open event for unknown email - attempting to create placeholder log", %{
          message_id: message_id
        })

        case create_placeholder_log_from_event(event_data, "opened") do
          {:ok, log} ->
            # Создаем event запись для созданного лога
            create_open_event(log, open_data, open_timestamp)

            Logger.info("Created placeholder log for open event", %{
              log_id: log.id,
              message_id: message_id
            })

            {:ok, %{type: "open", log_id: log.id, updated: true, created_placeholder: true}}

          {:error, reason} ->
            Logger.error("Failed to create placeholder log for open event", %{
              message_id: message_id,
              reason: inspect(reason)
            })

            {:error, :email_log_not_found}
        end
    end
  end

  # Обрабатывает событие клика
  defp process_click_event(event_data) do
    message_id = get_in(event_data, ["mail", "messageId"])
    click_data = event_data["click"]
    click_timestamp = get_in(click_data, ["timestamp"])

    case find_email_log_by_message_id(message_id) do
      {:ok, log} ->
        # Клик - наивысший уровень engagement
        update_attrs = %{status: "clicked"}

        case EmailLog.update_log(log, update_attrs) do
          {:ok, updated_log} ->
            # Создаем event запись
            create_click_event(updated_log, click_data, click_timestamp)

            Logger.info("Email link clicked", %{
              log_id: updated_log.id,
              message_id: message_id,
              link_url: get_in(click_data, ["link"]),
              ip_address: get_in(click_data, ["ipAddress"])
            })

            {:ok, %{type: "click", log_id: updated_log.id, updated: true}}

          {:error, reason} ->
            Logger.error("Failed to update click status", %{
              log_id: log.id,
              reason: inspect(reason)
            })

            {:error, reason}
        end

      {:error, :not_found} ->
        Logger.warning("Click event for unknown email - attempting to create placeholder log", %{message_id: message_id})

        case create_placeholder_log_from_event(event_data, "clicked") do
          {:ok, log} ->
            # Клик - наивысший уровень engagement
            update_attrs = %{status: "clicked"}

            case EmailLog.update_log(log, update_attrs) do
              {:ok, updated_log} ->
                # Создаем event запись
                create_click_event(updated_log, click_data, click_timestamp)

                Logger.info("Created placeholder log for click event", %{
                  log_id: updated_log.id,
                  message_id: message_id,
                  link_url: get_in(click_data, ["link"]),
                  ip_address: get_in(click_data, ["ipAddress"])
                })

                {:ok, %{type: "click", log_id: updated_log.id, updated: true, created_placeholder: true}}

              {:error, reason} ->
                Logger.error("Failed to update placeholder log for click", %{
                  log_id: log.id,
                  reason: inspect(reason)
                })

                {:error, reason}
            end

          {:error, reason} ->
            Logger.error("Failed to create placeholder log for click event", %{
              message_id: message_id,
              reason: inspect(reason)
            })

            {:error, :email_log_not_found}
        end
    end
  end

  ## --- Helper Functions ---

  # Находит email log по message_id с расширенным поиском
  defp find_email_log_by_message_id(message_id) when is_binary(message_id) do
    Logger.debug("SQSProcessor: Searching for email log", %{
      message_id: message_id,
      message_id_length: String.length(message_id)
    })

    # Первый поиск - прямой поиск по message_id
    case EmailTracking.get_log_by_message_id(message_id) do
      {:ok, log} ->
        Logger.debug("SQSProcessor: Found email log by direct message_id search", %{
          log_id: log.id,
          message_id: message_id
        })
        {:ok, log}

      {:error, :not_found} ->
        Logger.debug("SQSProcessor: Direct search failed, trying AWS message_id search", %{
          message_id: message_id
        })

        # Второй поиск - поиск по AWS message ID
        case PhoenixKit.EmailTracking.EmailLog.find_by_aws_message_id(message_id) do
          {:ok, log} ->
            Logger.info("SQSProcessor: Found email log by AWS message_id search", %{
              log_id: log.id,
              stored_message_id: log.message_id,
              search_message_id: message_id
            })
            {:ok, log}

          {:error, :not_found} ->
            Logger.warning("SQSProcessor: No email log found for message_id", %{
              message_id: message_id,
              searched_strategies: ["direct", "aws_field", "metadata"]
            })

            # Попробуем найти похожие записи для диагностики
            log_recent_emails_for_diagnosis(message_id)

            {:error, :not_found}
        end

      {:error, reason} ->
        Logger.error("SQSProcessor: Error during email log search", %{
          message_id: message_id,
          reason: inspect(reason)
        })
        {:error, reason}
    end
  end

  defp find_email_log_by_message_id(message_id) do
    Logger.error("SQSProcessor: Invalid message_id format", %{
      message_id: inspect(message_id),
      message_id_type: type_of(message_id)
    })
    {:error, :invalid_message_id}
  end

  # Логирует недавние emails для диагностики проблем поиска
  defp log_recent_emails_for_diagnosis(missing_message_id) do
    try do
      # Получаем последние 5 email логов для диагностики
      recent_logs = from(l in PhoenixKit.EmailTracking.EmailLog,
                      order_by: [desc: l.inserted_at],
                      limit: 5,
                      select: {l.id, l.message_id, l.inserted_at}
                    )
                    |> PhoenixKit.EmailTracking.EmailLog.repo().all()

      Logger.debug("SQSProcessor: Recent email logs for diagnosis", %{
        missing_message_id: missing_message_id,
        recent_logs: Enum.map(recent_logs, fn {id, msg_id, inserted_at} ->
          %{
            id: id,
            message_id: msg_id,
            inserted_at: inserted_at,
            matches_pattern: String.contains?(msg_id || "", String.slice(missing_message_id, 0, 10))
          }
        end)
      })
    rescue
      error ->
        Logger.debug("SQSProcessor: Failed to get recent logs for diagnosis: #{inspect(error)}")
    end
  end

  # Создает event запись для delivery
  defp create_delivery_event(log, delivery_data) do
    event_attrs = %{
      email_log_id: log.id,
      event_type: "delivery",
      event_data: delivery_data,
      occurred_at: parse_timestamp(get_in(delivery_data, ["timestamp"]))
    }

    EmailTracking.create_event(event_attrs)
  end

  # Создает event запись для bounce
  defp create_bounce_event(log, bounce_data) do
    event_attrs = %{
      email_log_id: log.id,
      event_type: "bounce",
      event_data: bounce_data,
      occurred_at: parse_timestamp(get_in(bounce_data, ["timestamp"])),
      bounce_type: get_in(bounce_data, ["bounceType"])
    }

    EmailTracking.create_event(event_attrs)
  end

  # Создает event запись для complaint
  defp create_complaint_event(log, complaint_data) do
    event_attrs = %{
      email_log_id: log.id,
      event_type: "complaint",
      event_data: complaint_data,
      occurred_at: parse_timestamp(get_in(complaint_data, ["timestamp"])),
      complaint_type: get_in(complaint_data, ["complaintFeedbackType"])
    }

    EmailTracking.create_event(event_attrs)
  end

  # Создает event запись для open
  defp create_open_event(log, open_data, timestamp) do
    event_attrs = %{
      email_log_id: log.id,
      event_type: "open",
      event_data: open_data,
      occurred_at: parse_timestamp(timestamp),
      ip_address: get_in(open_data, ["ipAddress"]),
      user_agent: get_in(open_data, ["userAgent"])
    }

    EmailTracking.create_event(event_attrs)
  end

  # Создает event запись для click
  defp create_click_event(log, click_data, timestamp) do
    event_attrs = %{
      email_log_id: log.id,
      event_type: "click",
      event_data: click_data,
      occurred_at: parse_timestamp(timestamp),
      link_url: get_in(click_data, ["link"]),
      ip_address: get_in(click_data, ["ipAddress"]),
      user_agent: get_in(click_data, ["userAgent"])
    }

    EmailTracking.create_event(event_attrs)
  end

  # Парсит timestamp строку в DateTime
  defp parse_timestamp(timestamp_string) when is_binary(timestamp_string) do
    case DateTime.from_iso8601(timestamp_string) do
      {:ok, datetime, _} -> datetime
      {:error, _} -> DateTime.utc_now()
    end
  end

  defp parse_timestamp(_), do: DateTime.utc_now()

  # Создает сообщение об ошибке для bounce
  defp build_bounce_error_message(bounce_data) do
    bounce_type = get_in(bounce_data, ["bounceType"])
    bounce_subtype = get_in(bounce_data, ["bounceSubType"])

    recipients = get_in(bounce_data, ["bouncedRecipients"]) || []

    recipient_details =
      Enum.map(recipients, fn recipient ->
        email = recipient["emailAddress"]
        status = recipient["status"]
        diagnostic = recipient["diagnosticCode"]

        parts = [email, status, diagnostic] |> Enum.filter(& &1) |> Enum.join(" - ")
        parts
      end)

    base_message = "#{bounce_type} bounce"

    base_message =
      if bounce_subtype, do: "#{base_message} (#{bounce_subtype})", else: base_message

    if Enum.empty?(recipient_details) do
      base_message
    else
      "#{base_message}: #{Enum.join(recipient_details, "; ")}"
    end
  end

  # Создает placeholder email log из данных события для случаев,
  # когда получаем события без предварительно созданного лога
  defp create_placeholder_log_from_event(event_data, initial_status) do
    mail_data = event_data["mail"] || %{}
    message_id = get_in(mail_data, ["messageId"])

    # Извлекаем основные данные из события
    destination = get_in(mail_data, ["destination"]) || []
    source = get_in(mail_data, ["source"])

    # Определяем получателя (первый в списке destination)
    to_email =
      case destination do
        [first | _] when is_binary(first) -> first
        _ -> "unknown@example.com"
      end

    # Определяем отправителя
    from_email =
      case source do
        email when is_binary(email) -> email
        _ -> "unknown@example.com"
      end

    # Получаем общую информацию из mail объекта
    subject = get_in(mail_data, ["commonHeaders", "subject"]) || "(no subject)"
    timestamp = get_in(mail_data, ["timestamp"])

    log_attrs = %{
      message_id: message_id,
      to: to_email,
      from: from_email,
      subject: subject,
      status: initial_status,
      sent_at: parse_timestamp(timestamp),
      headers: %{
        "x-placeholder-log" => "true",
        "x-created-from-event" => event_data["eventType"] || "unknown"
      },
      body_preview: "(email body not available - created from event)",
      provider: "aws_ses",
      template_name: "placeholder",
      campaign_id: "recovered_from_event"
    }

    EmailTracking.create_log(log_attrs)
  end
end
